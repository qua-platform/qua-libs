# %%
"""
This script is used to populate the quam generated by running generate_quam.py with initial values based on previous
calibrations or chip manufacturer specs and must be run prior to conducting the first experiment.
It is split according to the component to update (resonator, qubit xy drive, flux line) and allows the user to specify
the different frequencies and power involved. Other parameters are directly related to the control hardware such as
full_scale_power_dbm, band, upsampling_mode...
The last section is dedicated to adding pulses for the single qubit gates and setting the initial values for the
readout and saturation pulses.
"""

########################################################################################################################
# %%                                             Import section
########################################################################################################################
import json
from qualang_tools.units import unit
from quam_config import Quam
from quam_builder.builder.superconducting.pulses import add_DragCosine_pulses, add_default_transmon_pair_pulses
from quam_builder.architecture.superconducting.custom_gates import CRGate, StarkInducedCZGate
from quam.components import pulses
import numpy as np
from pprint import pprint

########################################################################################################################
# %%                                 QUAM loading and auxiliary functions
########################################################################################################################
# Loads the QUAM
machine = Quam.load()
# Class containing tools to help handling units and conversions.
u = unit(coerce_to_integer=True)


def get_band(freq):
    """Determine the MW fem DAC band corresponding to a given frequency.

    Args:
        freq (float): The frequency in Hz.

    Returns:
        int: The Nyquist band number.
            - 1 if 50 MHz <= freq < 5.5 GHz
            - 2 if 4.5 GHz <= freq < 7.5 GHz
            - 3 if 6.5 GHz <= freq <= 10.5 GHz

    Raises:
        ValueError: If the frequency is outside the MW fem bandwidth [50 MHz, 10.5 GHz].
    """
    if 50e6 <= freq < 5.5e9:
        return 1
    elif 4.5e9 <= freq < 7.5e9:
        return 2
    elif 6.5e9 <= freq <= 10.5e9:
        return 3
    else:
        raise ValueError(f"The specified frequency {freq} Hz is outside of the MW fem bandwidth [50 MHz, 10.5 GHz]")


def closest_number(lst, target):
    return min(lst, key=lambda x: abs(x - target))


def get_full_scale_power_dBm_and_amplitude(desired_power: float, max_amplitude: float = 0.5) -> tuple[int, float]:
    """Get the full_scale_power_dbm and waveform amplitude for the MW FEM to output the specified desired power.

    The keyword `full_scale_power_dbm` is the maximum power of normalized pulse waveforms in [-1,1].
    To convert to voltage:
        power_mw = 10**(full_scale_power_dbm / 10)
        max_voltage_amp = np.sqrt(2 * power_mw * 50 / 1000)
        amp_in_volts = waveform * max_voltage_amp
        ^ equivalent to OPX+ amp
    Its range is -11dBm to +16dBm with 3dBm steps.

    Args:
        desired_power (float): Desired output power in dBm.
        max_amplitude (float, optional): Maximum allowed waveform amplitude in V. Default is 0.5V.

    Returns:
        tuple[float, float]: The full_scale_power_dBm and waveform amplitude realizing the desired power.
    """
    allowed_powers = [-11, -8, -5, -2, 1, 4, 7, 10, 13, 16]
    resulting_power = desired_power - 20 * np.log10(max_amplitude)
    if resulting_power < 0:
        full_scale_power_dBm = closest_number(allowed_powers, max(resulting_power + 3, -11))
    else:
        full_scale_power_dBm = closest_number(allowed_powers, min(resulting_power + 3, 16))
    amplitude = 10 ** ((desired_power - full_scale_power_dBm) / 20)
    if -11 <= full_scale_power_dBm <= 16 and -1 <= amplitude <= 1:
        return full_scale_power_dBm, amplitude
    else:
        raise ValueError(
            f"The desired power is outside the specifications ([-11; +16]dBm, [-1; +1]), got ({full_scale_power_dBm}; {amplitude})"
        )



########################################################################################################################
# %%                                    Resonator parameters
########################################################################################################################
# Update frequencies - be aware of coupled ports for bands
# The keyword "band" refers to the following frequency bands:
#   1: (50 MHz - 5.5 GHz)
#   2: (4.5 GHz - 7.5 GHz)
#   3: (6.5 GHz - 10.5 GHz)
# Note that the "coupled" ports O1 & I1, O2 & O3, O4 & O5, O6 & O7, and O8 & I2 must be in the same band.

# Resonator frequencies
rr_freq = np.array([
    7.05, 7.10, 7.15, 7.20,
    8.05, 8.10, 8.15, 8.20,
]) * u.GHz

rr_LO = np.array([
    7.25, 7.25, 7.25, 7.25,
    8.25, 8.25, 8.25, 8.25,
]) * u.GHz

rr_if = rr_freq - rr_LO  # The intermediate frequency is inferred from the LO and readout frequencies

assert np.all(np.abs(rr_if) < 400 * u.MHz), (
    "The resonator intermediate frequency must be within [-400; 400] MHz. \n"
    f"Readout frequencies: {rr_freq} \n"
    f"Readout LO frequency: {rr_LO} \n"
    f"Readout IF frequencies: {rr_if} \n"
)

# Desired output power in dBm - Must be within [-80, 16] dBm
readout_power = -11
# Get the full_scale_power_dBm and waveform amplitude corresponding to the desired powers
rr_full_scale, rr_amplitude = get_full_scale_power_dBm_and_amplitude(
    readout_power, max_amplitude=0.25 / len(machine.qubits)
)
rr_full_scale = 10 if rr_full_scale > 10 else rr_full_scale

# Update qubit rr freq and power
for k, qubit in enumerate(machine.qubits.values()):
    qubit.resonator.f_01 = rr_freq.tolist()[k]  # Resonator frequency optimized for discriminating 0 (|g>) and 1 (|e>)
    qubit.resonator.RF_frequency = qubit.resonator.f_01  # Readout frequency
    qubit.resonator.opx_output.full_scale_power_dbm = rr_full_scale  # Max readout power in dBm
    qubit.resonator.opx_output.upconverter_frequency = rr_LO[k]  # Readout up-converter frequency
    qubit.resonator.opx_input.band = get_band(rr_LO[k])  # Readout band for the up-conversion
    qubit.resonator.opx_output.band = get_band(rr_LO[k])  # Readout band for the down-conversion


########################################################################################################################
# %%                                    Qubit parameters
########################################################################################################################
# The keyword "band" refers to the following frequency bands:
#   1: (50 MHz - 5.5 GHz)
#   2: (4.5 GHz - 7.5 GHz)
#   3: (6.5 GHz - 10.5 GHz)
# Note that the "coupled" ports O1 & I1, O2 & O3, O4 & O5, O6 & O7, and O8 & I2 must be in the same band.

# Qubit drive frequencies
xy_freq = np.array([
    5.05, 5.10, 5.15, 5.20,
    5.05, 5.10, 5.15, 5.20,
]) * u.GHz

xy_LO = np.array([
    5.35, 5.35, 5.35, 5.35,
    5.35, 5.35, 5.35, 5.35,
]) * u.GHz

xy_if = xy_freq - xy_LO  # The intermediate frequency is inferred from the LO and qubit frequencies
assert np.all(np.abs(xy_if) < 400 * u.MHz), (
    "The xy intermediate frequency must be within [-400; 400] MHz. \n"
    f"Qubit drive frequencies: {xy_freq} \n"
    f"Qubit drive LO frequencies: {xy_LO} \n"
    f"Qubit drive IF frequencies: {xy_if} \n"
)
# Transmon anharmonicity
anharmonicity = np.array([
    250, 250, 250, 250,
    250, 250, 250, 250,
]) * u.MHz

# Desired output power in dBm
drive_power = -11
# Get the full_scale_power_dBm and waveform amplitude corresponding to the desired powers
xy_full_scale, xy_amplitude = get_full_scale_power_dBm_and_amplitude(drive_power)

# Update qubit xy freq and power
for k, qubit in enumerate(machine.qubits.values()):
    print(f"{qubit.name} - ")
    qubit.f_01 = xy_freq.tolist()[k]  # Qubit 0 to 1 (|g> -> |e>) transition frequency
    qubit.xy.RF_frequency = qubit.f_01  # Qubit drive frequency
    qubit.xy.opx_output.full_scale_power_dbm = xy_full_scale  # Max drive power in dBm
    # qubit.xy.opx_output.upconverter_frequency = None # xy_LO.tolist()[k]  # Qubit drive up-converter frequency
    qubit.xy.opx_output.upconverters = {
        1: {"frequency": xy_LO.tolist()[k]},
        2: {"frequency": 5.4 * u.GHz},
    }
    qubit.xy.opx_output.band = get_band(xy_LO.tolist()[k])  # Qubit drive band for the up-conversion
    # qubit.xy.LO_frequency = xy_LO.tolist()[k] # f"#/qubits/{qubit.name}/xy/upconverter_frequency"
    print(f"{qubit.name} - .xy UCF: {qubit.xy.upconverter_frequency}")
    print(f"{qubit.name} - .xy LO: {qubit.xy.LO_frequency}")

    qubit.xy_detuned.RF_frequency = f"#/qubits/{qubit.name}/xy/RF_frequency"
    qubit.xy_detuned.upconverter = qubit.xy.upconverter


# Assign shared cores
for k, qubit in enumerate(machine.qubits.values()):
    rr = qubit.resonator
    xy = qubit.xy
    qubit.resonator.core = f"{qubit.name}_{qubit.xy.opx_output.controller_id}_slot{rr.opx_output.fem_id}"
    qubit.xy.core = f"{qubit.name}_{qubit.xy.opx_output.controller_id}_slot{xy.opx_output.fem_id}"

for k, qp in enumerate(machine.qubit_pairs.values()):
    qc = qp.qubit_control
    qp.cross_resonance.core = f"{qc.name}_{qc.xy.opx_output.controller_id}_slot{qc.xy.opx_output.fem_id}"

for k, qp in enumerate(machine.qubit_pairs.values()):
    qc = qp.qubit_control
    qp.zz_drive.core = f"{qc.name}_{qc.xy.opx_output.controller_id}_slot{qc.xy.opx_output.fem_id}"


########################################################################################################################
# %%                                        Pulse parameters
########################################################################################################################
# How to add new pulses
# from quam.components.pulses import (
#     SquarePulse,
#     DragGaussianPulse,
#     DragCosinePulse,
#     FlatTopGaussianPulse,
#     WaveformPulse,
#     SquareReadoutPulse,
# )
# e.g., machine.qubits[q].xy.operations["new_pulse"] = FlatTopGaussianPulse(...)

## Update pulses
for k, q in enumerate(machine.qubits):
    # readout
    machine.qubits[q].resonator.operations["readout"].length = 1.0 * u.us
    machine.qubits[q].resonator.operations["readout"].amplitude = rr_amplitude
    # Qubit saturation
    machine.qubits[q].xy.operations["saturation"].length = 30 * u.us
    machine.qubits[q].xy.operations["saturation"].amplitude = 0.5 * xy_amplitude
    # Single qubit gates - DragCosine
    add_DragCosine_pulses(
        machine.qubits[q],
        amplitude=xy_amplitude,
        length=40,
        anharmonicity=anharmonicity.tolist()[k],
        alpha=0.0,
        detuning=0,
    )
    # # resonator const
    machine.qubits[q].resonator.operations["const"] = pulses.SquarePulse(
        length=1 * u.us,
        amplitude=0.5,
        axis_angle=0.0,
    )
    # Qubit const
    machine.qubits[q].xy.operations["const"] = pulses.SquarePulse(
        length=1 * u.us,
        amplitude=0.5,
        axis_angle=0.0,
    )



# %%                       
for k, qp in enumerate(machine.qubit_pairs):
    add_default_transmon_pair_pulses(qp)
    qb_pair = machine.qubit_pairs[qp]
    qp_name = qb_pair.name
    # qbt = qb_pair.qubit_target
    # qb_pair.cross_resonance.target_qubit_LO_frequency = f"#/qubits/{qbt.name}/xy/LO_frequency"
    # qb_pair.cross_resonance.target_qubit_IF_frequency = f"#/qubits/{qbt.name}/xy/intermediate_frequency"
    # qb_pair.cross_resonance.intermediate_frequency = f"#./inferred_intermediate_frequency"

    qt = qb_pair.qubit_target
    qb_pair.cross_resonance.target_qubit_LO_frequency = f"#/qubits/{qt.name}/xy/LO_frequency"
    qb_pair.cross_resonance.target_qubit_IF_frequency = f"#/qubits/{qt.name}/xy/intermediate_frequency"
    qb_pair.cross_resonance.LO_frequency = f"#/qubits/{qt.name}/xy/LO_frequency"
    qb_pair.cross_resonance.intermediate_frequency = f"#./inferred_intermediate_frequency"

    qc = qb_pair.qubit_control
    qc.xy.opx_output.upconverters.parent = None
    qc.xy.opx_output.upconverters[2]["frequency"] = f"#/qubits/{qt.name}/xy/LO_frequency"
    qb_pair.cross_resonance.opx_output.upconverter_frequency = None
    qb_pair.cross_resonance.upconverter = 2

    print(f"{qp_name} - CR LO: {qb_pair.cross_resonance.opx_output.upconverters[2]['frequency']}")
    print(f"{qp_name} - CR IF: {qb_pair.cross_resonance.intermediate_frequency}")
    print(f"{qp_name} - CR target_qubit_LO_frequency: {qb_pair.cross_resonance.target_qubit_LO_frequency}")
    print(f"{qp_name} - CR target_qubit_IF_frequency: {qb_pair.cross_resonance.target_qubit_IF_frequency}")
    print(f"{qp_name} - CR LO_frequency: {qb_pair.cross_resonance.LO_frequency}")

    qb_pair.zz_drive.target_qubit_LO_frequency = f"#/qubits/{qt.name}/xy/LO_frequency"
    qb_pair.zz_drive.target_qubit_IF_frequency = f"#/qubits/{qt.name}/xy/intermediate_frequency"
    qb_pair.zz_drive.LO_frequency = f"#/qubits/{qt.name}/xy/LO_frequency"
    qb_pair.zz_drive.detuning = -30 * u.MHz
    # qt.xy_detuned.RF_frequency = None
    qt.xy_detuned.RF_frequency = f"#./inferred_RF_frequency"
    qt.xy_detuned.intermediate_frequency = f"#./inferred_intermediate_frequency"
    qt.xy_detuned.detuning = -30 * u.MHz
    qb_pair.zz_drive.intermediate_frequency = f"#./inferred_intermediate_frequency"
    qb_pair.zz_drive.opx_output.upconverter_frequency = None
    qb_pair.zz_drive.upconverter = 2

    print(f"{qp_name} - ZZ LO: {qb_pair.zz_drive.opx_output.upconverters[2]['frequency']}")
    print(f"{qp_name} - ZZ IF: {qb_pair.zz_drive.intermediate_frequency}")
    print(f"{qp_name} - ZZ target_qubit_LO_frequency: {qb_pair.zz_drive.target_qubit_LO_frequency}")
    print(f"{qp_name} - ZZ target_qubit_IF_frequency: {qb_pair.zz_drive.target_qubit_IF_frequency}")
    print(f"{qp_name} - ZZ LO_frequency: {qb_pair.zz_drive.LO_frequency}")

    # Cross Resonance
    qb_pair.macros["cr"] = CRGate()
    # square
    qb_pair.cross_resonance.operations["square"] = pulses.SquarePulse(
        length=100,
        amplitude=1.0,
        axis_angle=0.0,
    )
    qb_pair.qubit_target.xy.operations[f"cr_square_{qb_pair.name}"] = pulses.SquarePulse(
        length=100,
        amplitude=1.0,
        axis_angle=0.0,
    )
    # cosine
    qb_pair.cross_resonance.operations["cosine"] = pulses.DragCosinePulse(
        length=100,
        amplitude=1.0,
        axis_angle=0.0,
        anharmonicity=260 * u.MHz,
        alpha=0.0,
        detuning=0,
        # correction_phase=0.0,
    )
    qb_pair.qubit_target.xy.operations[f"cr_cosine_{qb_pair.name}"]= pulses.DragCosinePulse(
        length=100,
        amplitude=1.0,
        axis_angle=0.0,
        anharmonicity=260 * u.MHz,
        alpha=0.0,
        detuning=0,
    )
    # gauss
    qb_pair.cross_resonance.operations["gauss"] = pulses.DragGaussianPulse(
        length=100,
        sigma=100 / 5,
        amplitude=1.0,
        axis_angle=0.0,
        anharmonicity=260 * u.MHz,
        alpha=0.0,
        detuning=0,
        # correction_phase=0.0,
    )
    qb_pair.qubit_target.xy.operations[f"cr_gauss_{qb_pair.name}"]= pulses.DragGaussianPulse(
        length=100,
        sigma=100 / 5,
        amplitude=1.0,
        axis_angle=0.0,
        anharmonicity=260 * u.MHz,
        alpha=0.0,
        detuning=0,
    )
    # flattop
    rise_fall_len = 8
    flattop_len = 84 # must be python list (not numpy array)
    qb_pair.cross_resonance.operations["flattop"] = pulses.FlatTopGaussianPulse(
        amplitude=1.0,
        length=rise_fall_len + flattop_len + rise_fall_len,
        flat_length=flattop_len,
        axis_angle=0.0, 
    )
    qb_pair.qubit_target.xy.operations[f"cr_flattop{qb_pair.name}"] = pulses.FlatTopGaussianPulse(
        amplitude=1.0,
        length=rise_fall_len + flattop_len + rise_fall_len,
        flat_length=flattop_len,
        axis_angle=0.0, 
    )

    # Stark-induced ZZ
    qb_pair.macros["stark_cz"] = StarkInducedCZGate()
    # square
    qb_pair.zz_drive.operations["square"] = pulses.SquarePulse(
        length=100,
        amplitude=1.0,
        axis_angle=0.0,
    )
    qb_pair.qubit_target.xy_detuned.operations[f"zz_square_{qb_pair.name}"] = pulses.SquarePulse(
        length=100,
        amplitude=1.0,
        axis_angle=0.0,
    )
    # cosine
    qb_pair.zz_drive.operations["cosine"] = pulses.DragCosinePulse(
        length=100,
        amplitude=1.0,
        axis_angle=0.0,
        anharmonicity=260 * u.MHz,
        alpha=0.0,
        detuning=0,
        # correction_phase=0.0,
    )
    qb_pair.qubit_target.xy_detuned.operations[f"zz_cosine_{qb_pair.name}"] = pulses.DragCosinePulse(
        length=100,
        amplitude=1.0,
        axis_angle=0.0,
        anharmonicity=260 * u.MHz,
        alpha=0.0,
        detuning=0,
    )
    # gauss
    qb_pair.zz_drive.operations["gauss"] = pulses.DragGaussianPulse(
        length=100,
        sigma=100 / 5,
        amplitude=1.0,
        axis_angle=0.0,
        anharmonicity=260 * u.MHz,
        alpha=0.0,
        detuning=0,
        # correction_phase=0.0,
    )
    qb_pair.qubit_target.xy_detuned.operations[f"zz_gauss_{qb_pair.name}"] = pulses.DragGaussianPulse(
        length=100,
        sigma=100 / 5,
        amplitude=1.0,
        axis_angle=0.0,
        anharmonicity=260 * u.MHz,
        alpha=0.0,
        detuning=0,
    )
    # flattop
    rise_fall_len = 8
    flattop_len = 84  # must be python list (not numpy array)
    qb_pair.zz_drive.operations["flattop"] = pulses.FlatTopGaussianPulse(
        amplitude=1.0,
        length=rise_fall_len + flattop_len + rise_fall_len,
        flat_length=flattop_len,
        axis_angle=0.0,
    )
    qb_pair.qubit_target.xy_detuned.operations[f"zz_flattop_{qb_pair.name}"] = pulses.FlatTopGaussianPulse(
        amplitude=1.0,
        length=rise_fall_len + flattop_len + rise_fall_len,
        flat_length=flattop_len,
        axis_angle=0.0,
    )



########################################################################################################################
# %%                                        Plot parameters
########################################################################################################################

# Grid layout (2 columns: column 0 and column 1, from top to bottom)
# Each entry is in the format "column-row" (i.e., "col-row")
#
#   0,3 | 1,3
#   0,2 | 1,2
#   0,1 | 1,1
#   0,0 | 1,0
#
# Represented in row,major order from top row (3) to bottom row (0)


# qubits = [
#     1, 2, 3, 4,
#     5, 6, 7, 8,
# ]
grid_locations = [
    "0,3", "0,2", "0,1", "0,0",
    "1,3", "1,2", "1,1", "1,0",
]
for gd, qubit in zip(grid_locations, machine.qubits.values()):
    qubit.grid_location = gd  # Qubit grid location for plotting as "column,row"


# qubit_pairs = [
#     (1, 2), (2, 1),
#     (2, 3), (3, 2),
#     (3, 4), (4, 3),

#     (5, 6), (6, 5),
#     (6, 7), (7, 6),
#     (7, 8), (8, 7),
# ]
grid_locations = [
    "0,3", "0,2",
    "0,1", "0,0",

    "1,3", "1,2",
    "1,1", "1,0",

    "2,3", "2,2",
    "2,1", "2,0",
]
for gd, qp in zip(grid_locations, machine.qubit_pairs.values()):
    qp.grid_location = gd


########################################################################################################################
# %%                                         Save the updated QUAM
########################################################################################################################
# save into state.json
machine.save()
# Visualize the QUA config and save it
pprint(machine.generate_config())
with open("qua_config.json", "w+") as f:
    json.dump(machine.generate_config(), f, indent=4)

# %%
