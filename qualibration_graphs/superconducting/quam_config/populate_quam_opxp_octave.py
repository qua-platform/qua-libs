"""
This script is used to populate the quam generated by running generate_quam.py with initial values based on previous
calibrations or chip manufacturer specs and must be run prior to conducting the first experiment.
It is split according to the component to update (resonator, qubit xy drive, flux line) and allows the user to specify
the different frequencies and power involved. Other parameters are directly related to the control hardware such as
gain, output_mode...
The last section is dedicated to adding pulses for the single qubit gates and setting the initial values for the
readout and saturation pulses.
"""

########################################################################################################################
# %%                                             Import section
########################################################################################################################
import json
from qualang_tools.units import unit
from quam_config import Quam
from quam_builder.builder.superconducting.pulses import add_DragCosine_pulses
from quam.components.pulses import GaussianPulse
import numpy as np
from pprint import pprint


########################################################################################################################
# %%                                 QUAM loading and auxiliary functions
########################################################################################################################
# Loads the QUAM
machine = Quam.load()
# Class containing tools to help handling units and conversions.
u = unit(coerce_to_integer=True)


def get_octave_gain_and_amplitude(desired_power: float, max_amplitude: float = 0.125) -> tuple[float, float]:
    """Get the Octave gain and IF amplitude for the Octave to output the specified desired power.

    Args:
        desired_power (float): Desired output power in dBm.
        max_amplitude (float, optional): Maximum allowed IF amplitude provided by the OPX to the Octave in V. Default is 0.125V, which is the optimum for driving the Octave up-conversion mixers.

    Returns:
        tuple[float, float]: The Octave gain and IF amplitude realizing the desired power.
    """

    resulting_power = desired_power - u.volts2dBm(max_amplitude)
    if resulting_power < 0:
        octave_gain = round(max(desired_power - u.volts2dBm(max_amplitude) + 0.5, -20) * 2) / 2
    else:
        octave_gain = round(min(desired_power - u.volts2dBm(max_amplitude) + 0.5, 20) * 2) / 2
    amplitude = u.dBm2volts(desired_power - octave_gain)

    if -20 <= octave_gain <= 20 and -0.5 <= amplitude < 0.5:
        return octave_gain, amplitude
    else:
        raise ValueError(
            f"The desired power is outside the specifications ([-20; +20]dBm, [-0.5; +0.5)V), got ({octave_gain}; {amplitude})"
        )


########################################################################################################################
# %%                                    Resonator parameters
########################################################################################################################
# Be mindful that the Octave LO synthesizers are shared between ports:
#    synth1: RF1 and RFin1
#    synth2: RF2 and RF3
#    synth3: RF4 and RF5
# Octave LO frequency [2 : 0.250 : 18] GHz
# Octave gain [-20 : 0.5 : 20] dB
# Please refer to https://docs.quantum-machines.co/latest/docs/Guides/octave/ for more details

# Resonator frequencies
rr_freq = np.array([4.395, 4.422, 4.541, 4.728]) * u.GHz
rr_LO = 4.5 * u.GHz
rr_if = rr_freq - rr_LO  # The intermediate frequency is inferred from the LO and readout frequencies
assert np.all(np.abs(rr_if) < 400 * u.MHz), "The resonator intermediate frequency must be within [-400; 400] MHz."

# Desired output power in dBm - Must be within [-80, 16] dBm
readout_power = -40
# Get the Octave gain and IF amplitude corresponding to the desired powers
rr_gain, rr_amplitude = get_octave_gain_and_amplitude(readout_power, max_amplitude=0.125 / len(machine.qubits))

# Update qubit rr freq and power
for k, qubit in enumerate(machine.qubits.values()):
    qubit.resonator.f_01 = rr_freq.tolist()[k]  # Resonator frequency optimized for discriminating 0 (|g>) and 1 (|e>)
    qubit.resonator.RF_frequency = qubit.resonator.f_01  # Readout frequency
    qubit.resonator.frequency_converter_up.LO_frequency = rr_LO  # Octave LO frequency [2 : 0.250 : 18] GHz
    qubit.resonator.frequency_converter_up.gain = rr_gain  # Octave gain [-20 : 0.5 : 20] dB
    qubit.resonator.frequency_converter_up.output_mode = "always_on"  # Octave RF switch mode "always_on" or "triggered"


########################################################################################################################
# %%                                    Qubit parameters
########################################################################################################################
# Be mindful that the Octave LO synthesizers are shared between ports:
#    synth1: RF1 and RFin1
#    synth2: RF2 and RF3
#    synth3: RF4 and RF5
# Octave LO frequency [2 : 0.250 : 18] GHz
# Octave gain [-20 : 0.5 : 20] dB
# Please refer to https://docs.quantum-machines.co/latest/docs/Guides/octave/ for more details

# Qubit drive frequencies
xy_freq = np.array([6.012, 6.421, 6.785, 7.001]) * u.GHz
xy_LO = np.array([6.25, 6.25, 6.75, 6.75]) * u.GHz
xy_if = xy_freq - xy_LO  # The intermediate frequency is inferred from the LO and qubit frequencies
assert np.all(np.abs(xy_if) < 400 * u.MHz), "The xy intermediate frequency must be within [-400; 400] MHz."
# Transmon anharmonicity
anharmonicity = np.array([150, 200, 175, 310]) * u.MHz

# Desired output power in dBm
drive_power = -10
# Get the Octave gain and IF amplitude corresponding to the desired powers
xy_gain, xy_amplitude = get_octave_gain_and_amplitude(drive_power)

# Update qubit xy freq and power
for k, qubit in enumerate(machine.qubits.values()):
    qubit.f_01 = xy_freq.tolist()[k]  # Qubit 0 to 1 (|g> -> |e>) transition frequency
    qubit.xy.RF_frequency = qubit.f_01  # Qubit drive frequency
    qubit.xy.frequency_converter_up.LO_frequency = xy_LO.tolist()[k]  # Octave LO frequency [2 : 0.250 : 18] GHz
    qubit.xy.frequency_converter_up.gain = xy_gain  # Octave gain [-20 : 0.5 : 20] dB
    qubit.xy.frequency_converter_up.output_mode = "always_on"  # Octave RF switch mode "always_on" or "triggered"
    qubit.grid_location = f"{k},0"  # Qubit grid location for plotting as "column,row"


########################################################################################################################
# %%                                        Pulse parameters
########################################################################################################################
# How to add new pulses
# from quam.components.pulses import (
#     SquarePulse,
#     DragGaussianPulse,
#     DragCosinePulse,
#     FlatTopGaussianPulse,
#     WaveformPulse,
#     SquareReadoutPulse,
# )
# e.g., machine.qubits[q].xy.operations["new_pulse"] = FlatTopGaussianPulse(...)

## Update pulses
for k, q in enumerate(machine.qubits):
    # readout
    machine.qubits[q].resonator.operations["readout"].length = 2.5 * u.us
    machine.qubits[q].resonator.operations["readout"].amplitude = rr_amplitude
    # Qubit saturation
    machine.qubits[q].xy.operations["saturation"].length = 20 * u.us
    machine.qubits[q].xy.operations["saturation"].amplitude = 0.3
    # Single qubit gates - DragCosine
    add_DragCosine_pulses(
        machine.qubits[q],
        amplitude=xy_amplitude,
        length=40,
        anharmonicity=anharmonicity.tolist()[k],
        alpha=0.0,
        detuning=0,
    )
    # Single Gaussian flux pulse
    # if hasattr(machine.qubits[q], "z"):
    #     machine.qubits[q].z.operations["gauss"] = GaussianPulse(amplitude=0.1, length=200, sigma=40)

########################################################################################################################
# %%                                         Save the updated QUAM
########################################################################################################################
# save into state.json
machine.save()
# Visualize the QUA config and save it
pprint(machine.generate_config())
with open("qua_config.json", "w+") as f:
    json.dump(machine.generate_config(), f, indent=4)
