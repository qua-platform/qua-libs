# Gate Set Tomography with QUA

This script presents how one can perform Gate Set Tomography using a smart combination of the open-source package PyGSTi (https://github.com/pyGSTio/pyGSTi) and QUA for an efficient computation.

Reference: https://arxiv.org/pdf/2009.07301.pdf
# Introduction

Whereas usual state and process tomography do assume the existence of pre-calibrated gates allowing perfect state preparation and measurement stages, gate set tomography aims to perform a characterization which does not require any prior calibration or assumptions on the gates we use.
The way it is performed is by the description of an entire gate set that includes State Preparation and Measurement (SPAM) procedures. Where there exist multiple ways to address the GST sequence generation and post processing, we are interested here in proposing a nice way of using QUA to actually run the GST experiment in the lab, once the circuit list to be run has been generated using the GST models included in the PyGSTi package.

# 1. Reading the txt file originating from PyGSTi
The GST experiment can usually be broken down in a list of circuits that do have the same structure:
- State preparation stages, also called state fiducials
- Germs, which do amplify in all directions the sources of noise associated to each basis gate. It is usually repeated $$p$$ times where $$p$$ is an integer and can vary depending on the experiment conducted
- Measurement stages, also called measurement fiducials

The idea is to extract this structure from the txt file and the GST model generated by the PyGSTi package in order to build a set of inputs readable by the QUA program which will perform the play statements necessary to produce the circuit lists.
To do that, we must build a correspondence between a certain gate sequence indicated with basic names within the txt file, and a set of QUA macros which are containing a series of play statements that will actually implement the targeted gate sequences.

Our goal is to be able to generate in real-time the gate sequences required for GST. That requires an efficient encoding
of the sequences. The way we encode the circuits from PyGSTi is by assembling a minimal generating set of all the sequences
by taking a union of the prep fiducials, germs, and measurement fiducials. Using this generating set we are able to encode
each circuit with just 4 integers: [prep fiducial index, meas fiducial index, germ index, germ repitition].
Given the 4 numbers describing a circuit we can generate the associated pulses on-the-fly.

# 2. Loading the encoded sequences to the OPX 
GST experiments can be quite expensive in terms of computational resources as the list of circuits that can be run in one experiment can be extremely long. 
We can take a couple of different approaches to deal with that. First, in order to run them in one single QUA program, 
we can load iteratively the variables using the two IO variables using the function *encode_circuit_in_IO().* 
This carries the advantage of not having to launch a new QUA program for each iteration when saturating memory, but carries some latency between circuits.
Alternatively, we can divide the circuit list into multiple large chunks and run a program for each list.

# 3. Program Usage 
The usage of the class is pretty straightforward, as can be seen here:
```python
qmm = QuantumMachinesManager()
def x_pi2():
    play("x_pi/2", "qe1")
def y_pi2():
    play("y_pi/2", "qe1")
def id_gate():
    wait(pulse_len, "qe1")
def reset():
    active_reset("qe1")
def post_circuit(out_st):
    I = declare(fixed)
    measure("readoutOp", "qe1", None, I)
    save(I, out_st)
GST_sequence_file = "Circuits_before_results.txt"
gate_macros = {"xpi2:0": x_pi2, "ypi2:0": y_pi2, "[]": id_gate}
gst = QuaGST(
    file=GST_sequence_file,
    model=smq1Q_XYI,
    basic_gates_macros=gate_macros,
    N_shots=1,
    pre_circuit=reset,
    post_circuit=post_circuit,
    config=config,
    quantum_machines_manager=qmm,
)
gst.run(100)
# gst.run_IO() 
results = gst.results
```
All the user needs to provide is the path to the file containing a circuit list generated from a PyGSTi model, the PyGSTi
model used for the GST, and macros for the basic gates from which the circuits are generated (the names for the basic gates should be
given without the "G").
Additionally, the user also define the number of shots per circuit, and optional operation pre and post each circuit.
Finally, to run the script simply call one of two run methods, that will execute the circuit list using the provided configuration.
The results will be stored in a numpy array format inside the results attribute, that could be plugged back into the PyGSTi 
module for analysis.