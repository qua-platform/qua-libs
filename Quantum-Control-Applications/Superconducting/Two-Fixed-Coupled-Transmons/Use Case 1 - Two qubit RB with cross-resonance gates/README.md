# Two-qubit RB generated by cross-resonance CNOTs without pre-baking

_Authors and experimenters: Ziwen Huang, Paul Heidler, Nicholas Bornman_

*Important note: the code in this folder was used for performing two-qubit randomized benchmarking with cross-resonance*
*gates for a pair of coupled transmon qubits. This codebase would need to be tailored for the user's*
*particular setup.*

The main entrypoint file is [run_two_qubit_rb_CR_CNOT.py](run_two_qubit_rb_CR_CNOT.py), which relies on random Cliffords generation 
coded in [TwoQ_RB_Sequence_Generation_CNOT_CR.py](TwoQ_RB_Sequence_Generation_CNOT_CR.py). (Currently only tested for Python 3.10. Incompatibility was identified when running on Python 3.12+. This may be resolved later.)

Reference: Samuel Haberthür (2015), Randomized benchmarking of two-qubit gates, Master's Thesis, ETH Zurich.

## 1. Pre-requisite calibrations and some notes

* Calibrate readout pulses and optimize state discrimination.
* Calibrate and optimize qubit XY pulses. Single qubit operations are based on 'x90', '-x90', 'x180', 'y90', '-y90', and 'y180'.
* Our two qubit RB is based on a CNOT as the entangling operation which is implemented by direct CR gate. Any end user should replace the pertinent lines in the definition of the function `play_sequence` in [run_two_qubit_rb_CR_CNOT.py](run_two_qubit_rb_CR_CNOT.py) (precisely switch case 49) if echoed CR is to be used.
* The user can easily customize their gates, especially the two-qubit gate pulses.
* Running gate sequences other than those for RB is also possible if one manually sets the `sequence_list` (see TEST EXAMPLE in [run_two_qubit_rb_CR_CNOT.py](run_two_qubit_rb_CR_CNOT.py)).



## 2. [The configuration](configuration.py)


### 2.1 The elements
The configuration consists of 4 elements:
* `rr1` and `rr2` send readout pulses and measure the transmitted signal for each qubit
* `q1_xy` and `q2_xy` send drive XY pulses to each qubit
* In `cr_drive_c1t2`, qubit 1 acts as the control quubit and qubit 2 as the target. Conversely, in `cr_drive_c2t1` qubit 2 is the control qubit and qubit 1 is the target. They send cross-resonance drive to the control qubit (at the target frequency).
* In `cr_cancel_c1t2`, qubit 1 acts as the control qubit, and qubit 2 as the target. Conversely, in `cr_cancel_c2t1`, qubit 2 is the control qubit, and qubit 1 is the target. They send cancellation drive to the target qubit (also at the target frequency).

### 2.2 The operations, pulse and waveforms

The readout resonators `rr1` and `rr2` each have a 'readout' operation, each of which is a constant pulse with calibrated readout lengths and amplitudes.

The qubit elements `q1_xy` and `q2_xy` have several operations defined that correspond to 'X/2', 'Y/2', '-X/2', '-Y/2', 'X' and 'Y' gates. The envelopes are Gaussian (although this can be changed by the user), with optional Gaussian DRAG corrections and parameters (amplitudes, lengths, Gaussian sigmas, etc.), that need to be calibrated.

The qubit element `cr_drive_c1t2` and `cr_drive_c2t1` have both a square pulse waveform and a blackman function waveform options for the CR envelopes. The same holds true for `cr_cancel_c1t2` and `cr_cancel_c2t1`. 

## 3. How this RB code works

Below, we explain how the generate sequence function, defined in [run_two_qubit_rb_CR_CNOT.py](run_two_qubit_rb_CR_CNOT.py), works step by step.

### 3.1 Generate RB sequences by `generate_sequence_list`
(Similarly, one can generate IRB sequences by `generate_sequence_list_interleaved`.)

#### 3.1.1 For a given `depth`, `generate_sequence_list(depth)` first generates a sequence of random integers from the range 0-11519, with length `depth`. Each of these integers represents an element from the two-qubit Clifford group.

**Example**: for `depth=2`, we (presumably) get a random sequence `sequence_ints = [40, 599]`, corresponding to the 40th Clifford group element, followed by the 599th.

The 40th Clifford is 

    0: ─── X180 ────

    1: ─── Z90  ────

However, in terms of our XY pulses, the pulses sequence should be

    0: ─── X180 ──────────────────────

    1: ──  -X90 ──── Y90 ──── X90 ────

Next, the 599th Clifford is

    0: ─── I ────── C-CNOT ─── Y90 ──── X90 ───
              
    1: ─── Y180 ─── T-CNOT ─── -X90 ─── -Y90 ──

#### 3.1.2 The next step is to find the inverse gate/Clifford group element of the entire sequence, which is played at the end of the random sequence, to ensure that the final unitary, in the ideal case, is the identity.

**Example**: Using `cirq`, we append `circuit_list[40]` and `circuit_list[599]` to `circuit = cirq.Circuit()`.

Then we can evaluate the unitary of `circuit` by `cirq.unitary(circuit)`. Then we search through `unitary_list` to find the inverse matrix of `cirq.unitary(circuit)`.

In our example, integer 1567 corresponds to the inverse of Clifford operation 40 followed by operation 599. This inverse is appended to `sequence_ints`, which now is `[40, 599, 1567]`.

You get `circuit_list` and `unitary_list` by loading [2q_Clifford_gen_CNOT_circuit_cirq14.pkl](2q_Clifford_gen_CNOT_circuit_cirq_14.pkl) and [2q_Clifford_gen_CNOT_unitary.pkl](2q_Clifford_gen_CNOT_unitary.pkl). They contain the information of the 11520 Clifford gates.

#### 3.1.3: With one random RB sequence computed at the abstract "integer level", the next step is to translate this information into pulses compiled in [configuration.py](configuration.py).
We first use cirq to construct the full circuit, which is 

**Example**:

(Note that in the examples below, "0" is our control qubit and "1" is our target. This might be confusing as above we have used qubit 1 and 2 when naming the control lines.)

    0: ───X180──────────────────── I ────── CNOT-C ─── Y90 ──── X90 ─────Y90─── CNOT-C ─── I ─────────────
                                                                                                     
    1: ── -X90 ──── Y90 ──── X90───Y180 ─── CNOT-T ─── -X90 ─── -Y90 ────────── CNOT-T ─── Y90 ─── X90 ───


This circuit, which comprises a sequence of pulse operations, is then read in order, and every `moment` of this circuit is analyzed to see what happens to the qubits at each `moment`. For example, the first moment plays `X180` on qubit 0 and `-X90` on qubit 1, which can be summarized in a list of python tuples, as `[('x180', '0'), ('-x90', '1')]`. In this format, the full sequence of circuit instructions corresponds to

`instruct = [('x180', '0'),
('-x90', '1'),
('I', '0'),
('y90', '1'),
('I', '0'),
('x90', '1'),
('I', '0'),
('y180', '1'),
('CNOT', '01'),
('y90', '0'),
('-x90', '1'),
('x90', '0'),
('-y90', '1'),
('x90', '0'),
('y90', '1'),
('y90', '0'),
('I', '1'),
('CNOT', '01'),
('I', '0'),
('y90', '1'),
('I', '0'),
('x90', '1')]`

The above tranform is assisted by [2q_Clifford_gen_CNOT_instruct.pkl](2q_Clifford_gen_CNOT_instruct.pkl) where the string-formatted instruction for each Clifford is stored.

The list of tuples are still too complicated to compile per the authors' experimence. We'd better only pass as simple as integers to the QUA program. For this purpose, we write the function `instruct_to_integer(instruct)` to finally translate this list of strings as a list of integers -- each describes a concrete pulse instruction
precompiled in [configuration.py](configuration.py). As such, the `instruct` variable is translated to a list of integers between 0-49, according to the function `play_sequence` in [run_two_qubit_rb_CR_CNOT.py](run_two_qubit_rb_CR_CNOT.py).

**Example**:

The above `instruct` is translated into `instruct_integers`:

`[17, 28, 7, 42, 49, 18, 36, 29, 4, 49, 28, 7]`

Here, the first moment `('x180', '0'),
('-x90', '1')` corresponds to the integer instruction `17`.

### 3.2 Playing multiple random sequences with different depths

#### 3.2.1 Stacking all `instruct_integers` into `sequence_list`
We have one `instruct_integers` for each randomization and for each different depth, therefore a large number of integer lists needs to be inserted into a QUA program if many randomizations and depth choices are to be tested. Our solution is to use a single list to store all `instruct_integers` from different randomizations and for different `depth`'s. This is done by the function `pre_generate_sequence`.

Furthermore, it is important to also store the length of each individual `instruct_integers` variable to inform the qm program where to start and to stop for each iteration when reading `sequence_list`. That information is stored in `len_list`. 

### 3.2.2 Finally, `play_sequence` in loops.

Every time this function is used inside a QUA program, it is provided with the full list `sequence_list`. The QUA program is also fed with information instructing it where to `start` playing pulses, and the `length` of instructions the program needs to cycle over in each iteration.